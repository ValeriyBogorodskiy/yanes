using Snake;
using NesEmulatorCPU;
using OpenTK.Windowing.Common;

// Source: https://gist.github.com/wkjagt/9043907
var gameCode = new byte[] {
    0x20, 0x06, 0x06, 0x20, 0x38, 0x06, 0x20, 0x0d, 0x06, 0x20, 0x2a, 0x06, 0x60, 0xa9, 0x02, 0x85,
    0x02, 0xa9, 0x04, 0x85, 0x03, 0xa9, 0x11, 0x85, 0x10, 0xa9, 0x10, 0x85, 0x12, 0xa9, 0x0f, 0x85,
    0x14, 0xa9, 0x04, 0x85, 0x11, 0x85, 0x13, 0x85, 0x15, 0x60, 0xa5, 0xfe, 0x85, 0x00, 0xa5, 0xfe,
    0x29, 0x03, 0x18, 0x69, 0x02, 0x85, 0x01, 0x60, 0x20, 0x4d, 0x06, 0x20, 0x8d, 0x06, 0x20, 0xc3,
    0x06, 0x20, 0x19, 0x07, 0x20, 0x20, 0x07, 0x20, 0x2d, 0x07, 0x4c, 0x38, 0x06, 0xa5, 0xff, 0xc9,
    0x77, 0xf0, 0x0d, 0xc9, 0x64, 0xf0, 0x14, 0xc9, 0x73, 0xf0, 0x1b, 0xc9, 0x61, 0xf0, 0x22, 0x60,
    0xa9, 0x04, 0x24, 0x02, 0xd0, 0x26, 0xa9, 0x01, 0x85, 0x02, 0x60, 0xa9, 0x08, 0x24, 0x02, 0xd0,
    0x1b, 0xa9, 0x02, 0x85, 0x02, 0x60, 0xa9, 0x01, 0x24, 0x02, 0xd0, 0x10, 0xa9, 0x04, 0x85, 0x02,
    0x60, 0xa9, 0x02, 0x24, 0x02, 0xd0, 0x05, 0xa9, 0x08, 0x85, 0x02, 0x60, 0x60, 0x20, 0x94, 0x06,
    0x20, 0xa8, 0x06, 0x60, 0xa5, 0x00, 0xc5, 0x10, 0xd0, 0x0d, 0xa5, 0x01, 0xc5, 0x11, 0xd0, 0x07,
    0xe6, 0x03, 0xe6, 0x03, 0x20, 0x2a, 0x06, 0x60, 0xa2, 0x02, 0xb5, 0x10, 0xc5, 0x10, 0xd0, 0x06,
    0xb5, 0x11, 0xc5, 0x11, 0xf0, 0x09, 0xe8, 0xe8, 0xe4, 0x03, 0xf0, 0x06, 0x4c, 0xaa, 0x06, 0x4c,
    0x35, 0x07, 0x60, 0xa6, 0x03, 0xca, 0x8a, 0xb5, 0x10, 0x95, 0x12, 0xca, 0x10, 0xf9, 0xa5, 0x02,
    0x4a, 0xb0, 0x09, 0x4a, 0xb0, 0x19, 0x4a, 0xb0, 0x1f, 0x4a, 0xb0, 0x2f, 0xa5, 0x10, 0x38, 0xe9,
    0x20, 0x85, 0x10, 0x90, 0x01, 0x60, 0xc6, 0x11, 0xa9, 0x01, 0xc5, 0x11, 0xf0, 0x28, 0x60, 0xe6,
    0x10, 0xa9, 0x1f, 0x24, 0x10, 0xf0, 0x1f, 0x60, 0xa5, 0x10, 0x18, 0x69, 0x20, 0x85, 0x10, 0xb0,
    0x01, 0x60, 0xe6, 0x11, 0xa9, 0x06, 0xc5, 0x11, 0xf0, 0x0c, 0x60, 0xc6, 0x10, 0xa5, 0x10, 0x29,
    0x1f, 0xc9, 0x1f, 0xf0, 0x01, 0x60, 0x4c, 0x35, 0x07, 0xa0, 0x00, 0xa5, 0xfe, 0x91, 0x00, 0x60,
    0xa6, 0x03, 0xa9, 0x00, 0x81, 0x10, 0xa2, 0x00, 0xa9, 0x01, 0x81, 0x10, 0x60, 0xa2, 0x00, 0xea,
    0xea, 0xca, 0xd0, 0xfb, 0x60};

var cpu = new Cpu(new CPUSettings() { StartingProgramAddress = 0x0600 });
var cpuProcess = cpu.Run(gameCode);

var frameRate = 120;
var instructionsPerSecond = 3000;
var screenSize = 32;
var screenScaleFactor = 15;
var scaledScreenSize = screenSize * screenScaleFactor;
var bytesPerPixel = 3;
var scaledImage = new byte[bytesPerPixel * scaledScreenSize * scaledScreenSize];
var random = new Random();

using (SnakeWindow game = new(frameRate, scaledScreenSize, scaledScreenSize))
{
    game.UpdateFrame += args => OnUpdateFrame(game, cpu, cpuProcess, args);
    game.KeyDown += args => OnKeyDown(cpu, args);
    game.Run();
}

// TODO : extract scaling logic
void OnUpdateFrame(SnakeWindow game, Cpu cpu, IEnumerator<InstructionExecutionResult> cpuProcess, FrameEventArgs args)
{
    var intructionToExecute = (int)(instructionsPerSecond * args.Time);
    var randomValue = (byte)random.Next(1, 16);

    for (int i = 0; i < intructionToExecute; i++)
    {
        cpu.bus.Write8Bit(0xFE, randomValue);
        cpuProcess.MoveNext();
    }

    var topLeftPixelAddress = 0x0200;

    for (int i = 0; i < screenSize * screenSize; i++)
    {
        ushort pixelAddress = (ushort)(topLeftPixelAddress + i);
        byte colorByte = cpu.bus.Read8bit(pixelAddress) == 0 ? (byte)0 : (byte)255;

        var x = (i % screenSize) * screenScaleFactor;
        var y = (i / screenSize) * screenScaleFactor;

        for (int pixelX = 0; pixelX < screenScaleFactor; pixelX++)
        {
            for (int pixelY = 0; pixelY < screenScaleFactor; pixelY++)
            {
                var r = (x + pixelX) * bytesPerPixel + (y + pixelY) * bytesPerPixel * scaledScreenSize;
                var g = r + 1;
                var b = g + 1;

                scaledImage[r] = colorByte;
                scaledImage[g] = colorByte;
                scaledImage[b] = colorByte;
            }
        }
    }

    game.SetImage(scaledImage);
}

void OnKeyDown(Cpu cpu, KeyboardKeyEventArgs args)
{
    // TODO : controls are inverted because screen matrix is inverted in CPUs memory
    byte keyCode = args.Key switch
    {
        OpenTK.Windowing.GraphicsLibraryFramework.Keys.S => 0x77,
        OpenTK.Windowing.GraphicsLibraryFramework.Keys.A => 0x61,
        OpenTK.Windowing.GraphicsLibraryFramework.Keys.W => 0x73,
        OpenTK.Windowing.GraphicsLibraryFramework.Keys.D => 0x64,
        _ => 0
    };

    if (keyCode != 0)
    {
        cpu.bus.Write8Bit(0xFF, keyCode);
    }
}